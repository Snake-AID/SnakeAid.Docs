/* SnakeAid Unified ERD (DBML) */

Table users {
  id uuid [pk]
  full_name varchar
  email varchar
  phone varchar
  role varchar
  status varchar
  is_active boolean [default: true]
  created_at timestamptz
  updated_at timestamptz
}

Table patient_profile {
  user_id uuid [pk, not null, unique, ref: > users.id]
  emergency_contact varchar
}

Table rescuer_profile {
  user_id uuid [pk, not null, unique, ref: > users.id]
  experience_years int
  certification_level varchar
  is_verified boolean
  is_available boolean [default: false, note: "User toggles Open/Close; realtime presence still handled in Redis"]
  last_open_at timestamptz
  rating_avg numeric
  rating_count int
}

Table expert_profile {
  user_id uuid [pk, not null, unique, ref: > users.id]
  specialization varchar
  license_number varchar
  verified_at timestamp
}

Table system_event {
  id uuid [pk]
  event_type varchar
  actor_id uuid [ref: > users.id]
  actor_role varchar
  ref_type varchar
  ref_id uuid
  metadata json
  created_at timestamp
}

Table payment_card {
  id uuid [pk]
  user_id uuid [not null, ref: > users.id]
}

Table wallet {
  id uuid [pk]
  user_id uuid [not null, unique, ref: > users.id]
}

Table skill {
  id uuid [pk]
}

Table rescuer_skill {
  rescuer_id uuid [not null, ref: > rescuer_profile.user_id]
  skill_id uuid [not null, ref: > skill.id]

  Indexes {
    (rescuer_id, skill_id) [pk]
  }
}

Table expert_skill {
  expert_id uuid [not null, ref: > expert_profile.user_id]
  skill_id uuid [not null, ref: > skill.id]

  Indexes {
    (expert_id, skill_id) [pk]
  }
}

Table expert_experience {
  id uuid [pk]
  expert_id uuid [not null, ref: > expert_profile.user_id]
}

Table expert_pricing_rule {
  id uuid [pk]
  expert_id uuid [not null, ref: > expert_profile.user_id]
}

Table snake_species {
  id uuid [pk]
  slug varchar(120) [not null, unique, note: "Stable identifier, e.g. cap_nia_bac, ran_rao_trau"]

  scientific_name varchar(255) [unique, note: "e.g. Naja kaouthia"]
  common_name_default varchar(255) [note: "Default display name"]

  venomous_level varchar(32) [not null, note: "NON_VENOMOUS | MILD | MEDIUM | HIGH | UNKNOWN"]
  risk_priority int [not null, default: 0, note: "Higher = more prominent warning/priority"]

  status varchar(24) [not null, default: "DRAFT", note: "DRAFT | REVIEWING | PUBLISHED | ARCHIVED"]
  is_active boolean [not null, default: true]

  created_at timestamptz [not null, default: `now()`]
  updated_at timestamptz [not null, default: `now()`]
  created_by uuid [ref: > users.id]
  updated_by uuid [ref: > users.id]
}

Table snake_species_name {
  id uuid [pk]
  snake_species_id uuid [not null, ref: > snake_species.id]

  language_code varchar(10) [not null]
  name varchar(255) [not null]
  name_type varchar(24) [not null, default: "COMMON", note: "COMMON | LOCAL | ALIAS | MISSPELLING"]
  is_primary boolean [not null, default: false]

  created_at timestamptz [not null, default: `now()`]

  Indexes {
    (snake_species_id, language_code)
    (snake_species_id, language_code, name) [unique]
  }
}

Table snake_media {
  id uuid [pk]
  snake_species_id uuid [not null, ref: > snake_species.id]

  media_type varchar(16) [not null, note: "IMAGE | VIDEO"]
  url text [not null]
  caption varchar(255)
  source varchar(255)

  usage varchar(24) [not null, default: "LIBRARY", note: "LIBRARY | TRAINING | VERIFICATION"]
  is_primary boolean [not null, default: false]

  created_at timestamptz [not null, default: `now()`]

  Indexes {
    (snake_species_id, usage)
  }
}

Table snake_identification_profile {
  snake_species_id uuid [pk, ref: > snake_species.id]

  summary text
  key_features jsonb
  similar_species_notes text

  updated_at timestamptz [not null, default: `now()`]
}

Table snake_first_aid_guideline {
  id uuid [pk]
  snake_species_id uuid [not null, ref: > snake_species.id]

  version int [not null, default: 1]
  content_markdown text [not null]

  do_list jsonb
  dont_list jsonb
  when_to_call_emergency text

  is_published boolean [not null, default: false]
  published_at timestamptz

  created_at timestamptz [not null, default: `now()`]
  created_by uuid [ref: > users.id]

  Indexes {
    (snake_species_id, version) [unique]
    (snake_species_id, is_published)
  }
}

Table snake_distribution {
  id uuid [pk]
  snake_species_id uuid [not null, ref: > snake_species.id]

  region_type varchar(24) [not null, note: "COUNTRY | PROVINCE | ECOZONE"]
  region_code varchar(64) [not null, note: "ISO country code / province code / custom code"]

  notes text
  confidence int [not null, default: 50]

  created_at timestamptz [not null, default: `now()`]

  Indexes {
    (snake_species_id)
    (region_type, region_code)
  }
}

Table antivenom {
  id uuid [pk]
  name varchar(255) [not null, unique]
  manufacturer varchar(255)
  notes text
  is_active boolean [not null, default: true]

  created_at timestamptz [not null, default: `now()`]
  updated_at timestamptz [not null, default: `now()`]
}

Table snake_species_antivenom {
  snake_species_id uuid [not null, ref: > snake_species.id]
  antivenom_id uuid [not null, ref: > antivenom.id]

  evidence_note text

  Indexes {
    (snake_species_id, antivenom_id) [pk]
    (antivenom_id)
  }
}

Table ai_model {
  id uuid [pk]
  name varchar(255) [not null]
  version_tag varchar(64) [not null]
  nc int [not null]
  is_active boolean [not null, default: true]

  trained_at timestamptz
  notes text

  created_at timestamptz [not null, default: `now()`]
  updated_at timestamptz [not null, default: `now()`]

  Indexes {
    (name, version_tag) [unique]
  }
}

Table ai_model_class_map {
  id uuid [pk]
  ai_model_id uuid [not null, ref: > ai_model.id]

  class_id int [not null]
  class_label varchar(120) [not null]
  snake_species_id uuid [not null, ref: > snake_species.id]

  is_active boolean [not null, default: true]
  created_at timestamptz [not null, default: `now()`]

  Indexes {
    (ai_model_id, class_id) [unique]
    (ai_model_id, class_label)
    (snake_species_id)
  }
}

Table snake_library_audit_log {
  id uuid [pk]

  entity_type varchar(64) [not null]
  entity_id uuid [not null]
  action varchar(24) [not null]

  changed_by uuid [ref: > users.id]
  changed_at timestamptz [not null, default: `now()`]

  diff_json jsonb
}

Table snakebite_incident {
  id uuid [pk]
  patient_id uuid [not null, ref: > patient_profile.user_id]
  snake_species_id uuid [ref: > snake_species.id]
}

Table sos_request {
  id uuid [pk]
  incident_id uuid [not null, ref: > snakebite_incident.id]
}

Table patient_snakebite_history {
  id uuid [pk]
  patient_id uuid [not null, ref: > patient_profile.user_id]
  incident_id uuid [not null, ref: > snakebite_incident.id]
}

Table snake_question {
  id uuid [pk]
  incident_id uuid [not null, ref: > snakebite_incident.id]
  created_by_expert_id uuid [ref: > expert_profile.user_id]
}

Table symptom {
  id int [pk]
}

Table symptom_report {
  id uuid [pk]
  incident_id uuid [not null, ref: > snakebite_incident.id]
  symptom_id int [not null, ref: > symptom.id]
}

Table guideline.preparation_steps {
  id uuid [pk]
  steps jsonb
  content jsonb
}

Table snake_report {
  id uuid [pk]
  patient_id uuid [not null, ref: > patient_profile.user_id]
  snake_species_id uuid [ref: > snake_species.id]
  consultation_id uuid [ref: > consultation.id]
}

Table snake_ai_recognition {
  id uuid [pk]
}

Table snake_ai_recognition_snake_report {
  id uuid [pk]
  snake_ai_recognition_id uuid [not null, ref: > snake_ai_recognition.id]
  snake_report_id uuid [not null, ref: > snake_report.id]

  Indexes {
    (snake_ai_recognition_id, snake_report_id) [unique]
  }
}

Table rescue_mission {
  id uuid [pk]
  snake_report_id uuid [ref: > snake_report.id]
  sos_request_id uuid [ref: > sos_request.id]
  rescuer_id uuid [not null, ref: > rescuer_profile.user_id]
  payment_method_id uuid [ref: > payment_method.id]
}

Table rescue_tracking {
  id uuid [pk]
  rescue_mission_id uuid [not null, ref: > rescue_mission.id]
}

Table rescue_report {
  id uuid [pk]
  rescue_mission_id uuid [not null, ref: > rescue_mission.id]
}

Table rescuer_snake_handling_history {
  id uuid [pk]
  rescuer_id uuid [not null, ref: > rescuer_profile.user_id]
  rescue_mission_id uuid [not null, ref: > rescue_mission.id]
}

Table guideline.rescue_tools {
  id uuid [pk]
  content jsonb
}

Table guideline.safety_guideline {
  id uuid [pk]
  content jsonb
}

Table snake_quantity {
  id uuid [pk]
  rescue_mission_id uuid [not null, ref: > rescue_mission.id]
}

Table rescue_condition {
  id uuid [pk]
  rescue_mission_id uuid [not null, ref: > rescue_mission.id]
}

Table snake_price_rule {
  id uuid [pk]
  rescue_condition_id uuid [not null, ref: > rescue_condition.id]
  snake_species_id uuid [not null, ref: > snake_species.id]
}

Table snake_price_output {
  id uuid [pk]
  rescue_condition_id uuid [not null, ref: > rescue_condition.id]
}

Table revenue_share_config {
  id uuid [pk]
  content jsonb
}

Table consultation {
  id uuid [pk]
  patient_id uuid [ref: > patient_profile.user_id]
  rescuer_id uuid [ref: > rescuer_profile.user_id]
  expert_id uuid [not null, ref: > expert_profile.user_id]
  incident_id uuid [ref: > snakebite_incident.id]
}

Table consultation_note {
  id uuid [pk]
  consultation_id uuid [not null, ref: > consultation.id]
}

Table expert_schedule {
  id uuid [pk]
  expert_id uuid [not null, ref: > expert_profile.user_id]
  consultation_id uuid [unique, ref: > consultation.id]
}

Table rating {
  id uuid [pk]
  patient_id uuid [not null, ref: > patient_profile.user_id]
  rescuer_id uuid [ref: > rescuer_profile.user_id]
  expert_id uuid [ref: > expert_profile.user_id]
}

Table feedback {
  id uuid [pk]
  incident_id uuid [ref: > snakebite_incident.id]
  consultation_id uuid [ref: > consultation.id]
  patient_id uuid [ref: > patient_profile.user_id]
}

Table media_type {
  id int [pk]
}

Table media {
  id uuid [pk]
  media_type_id int [ref: > media_type.id]
  incident_id uuid [ref: > snakebite_incident.id]
  snake_report_id uuid [ref: > snake_report.id]
  consultation_id uuid [ref: > consultation.id]
  rescue_mission_id uuid [ref: > rescue_mission.id]
}

Table bite_verification {
  id uuid [pk]
  media_id uuid [not null, ref: > media.id]
  expert_id uuid [not null, ref: > expert_profile.user_id]
}

Table treatment_facility {
  id uuid [pk]
}

Table facility_antivenom {
  facility_id uuid [not null, ref: > treatment_facility.id]
  antivenom_id uuid [not null, ref: > antivenom.id]

  Indexes {
    (facility_id, antivenom_id) [pk]
  }
}

Table payment_method {
  id uuid [pk]
}

Table payment {
  id uuid [pk]
  payment_method_id uuid [not null, ref: > payment_method.id]
  wallet_id uuid [ref: > wallet.id]
  patient_id uuid [ref: > patient_profile.user_id]
  rescuer_id uuid [ref: > rescuer_profile.user_id]
  expert_id uuid [ref: > expert_profile.user_id]
  consultation_id uuid [ref: > consultation.id]
  rescue_mission_id uuid [ref: > rescue_mission.id]
  incident_id uuid [ref: > snakebite_incident.id]
}

Table payment_transaction {
  id uuid [pk]
  payment_id uuid [not null, unique, ref: > payment.id]
}

Table invoice {
  id uuid [pk]
  payment_id uuid [not null, ref: > payment.id]
}

Table platform_fee {
  id uuid [pk]
  payment_id uuid [not null, ref: > payment.id]
}

Table content {
  id uuid [pk]
  created_by uuid [not null, ref: > users.id]
}

Table community_alert {
  id uuid [pk]
  created_by uuid [not null, ref: > users.id]
}

Table map.device_tokens {
  id bigserial [pk]
  user_id uuid [ref: > users.id]
  platform varchar [note: "android | ios | web"]
  fcm_token varchar [unique]
  is_active boolean [default: true]
  last_seen_at timestamptz
  created_at timestamptz

  Indexes {
    (user_id, is_active)
    (last_seen_at)
  }
}

Table map.incidents {
  id uuid [pk]
  patient_id uuid [ref: > users.id]
  created_at timestamptz
  status map.incident_status

  // Location at time of SOS / report
  location geography [note: "PostGIS: geography(Point,4326)"]
  geohash varchar [note: "Optional: for coarse partitioning/analytics"]
  address_text varchar

  // Optional metadata for triage
  severity int [note: "0-5 or your own scale"]
  notes text

  Indexes {
    (patient_id, created_at)
    (status, created_at)
  }
}

Table map.rescue_sessions {
  id uuid [pk]
  incident_id uuid [ref: > map.incidents.id]
  patient_id uuid [ref: > users.id]
  assigned_rescuer_id uuid [ref: > users.id, null]
  status map.session_status

  created_at timestamptz
  accepted_at timestamptz
  started_at timestamptz
  completed_at timestamptz
  cancelled_at timestamptz
  cancel_reason varchar

  // Optional snapshot fields (not required if you always derive from events)
  eta_seconds int
  route_polyline text [note: "Optional; store if you compute ETA/route server-side"]

  Indexes {
    (incident_id)
    (assigned_rescuer_id, status)
    (status, created_at)
  }
}

Table map.rescue_offers {
  id uuid [pk]
  session_id uuid [ref: > map.rescue_sessions.id]
  rescuer_id uuid [ref: > users.id]

  attempt_no int [default: 1, note: "Redispatch increments attempt_no"]
  status map.offer_status

  // Dispatch timings
  sent_at timestamptz
  expires_at timestamptz
  acked_at timestamptz
  responded_at timestamptz

  // Useful for debugging delivery
  primary_channel map.notify_channel [note: "SIGNALR by default; FCM used as fallback"]
  last_error text

  Indexes {
    (session_id, attempt_no)
    (rescuer_id, status)
    (status, expires_at)
  }
}

Table map.session_participants {
  id bigserial [pk]
  session_id uuid [ref: > map.rescue_sessions.id]
  user_id uuid [ref: > users.id]
  role map.location_role
  joined_at timestamptz
  left_at timestamptz

  Indexes {
    (session_id, role)
    (user_id, joined_at)
  }
}

Table map.location_events {
  id bigserial [pk]
  session_id uuid [ref: > map.rescue_sessions.id]
  user_id uuid [ref: > users.id]
  role map.location_role

  ts timestamptz
  geom geography [note: "PostGIS: geography(Point,4326)"]
  geohash varchar [note: "Optional; precompute if needed"]
  seq int [note: "Monotonic per user/session; helps de-dup/order"]
  source map.location_source

  speed_mps real
  heading_deg real
  accuracy_m real

  Indexes {
    (session_id, ts)
    (user_id, ts)
  }
}

Table map.notification_log {
  id bigserial [pk]
  user_id uuid [ref: > users.id]
  session_id uuid [ref: > map.rescue_sessions.id, null]
  offer_id uuid [ref: > map.rescue_offers.id, null]

  type map.notify_type
  channel map.notify_channel

  title varchar
  body text
  payload_json jsonb

  provider_message_id varchar
  status varchar [note: "QUEUED | SENT | FAILED"]
  error text

  created_at timestamptz
  sent_at timestamptz

  Indexes {
    (user_id, created_at)
    (session_id, created_at)
    (type, created_at)
  }
}


// Gộp từ Map.dbml với schema 'map'
Enum map.incident_status {
  CREATED
  DISPATCHING
  RESCUER_ASSIGNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  EXPIRED
}

Enum map.session_status {
  PENDING
  OFFERING
  ACCEPTED
  EN_ROUTE
  ARRIVED
  COMPLETED
  CANCELLED
  EXPIRED
}

Enum map.offer_status {
  PENDING
  ACKED
  ACCEPTED
  REJECTED
  EXPIRED
  CANCELLED
}

Enum map.notify_type {
  NEW_OFFER
  OFFER_EXPIRES_SOON
  OFFER_CANCELLED
  RESCUER_ASSIGNED
  RESCUER_ARRIVING
  SESSION_CANCELLED
  SESSION_COMPLETED
}

Enum map.notify_channel {
  SIGNALR
  FCM
}

Enum map.location_role {
  PATIENT
  RESCUER
}

Enum map.location_source {
  GPS
  NETWORK
  MANUAL
}